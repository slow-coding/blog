
## 什么是编程？

> 我们所面临的挑战和任务是在`实际的进度`<sub>1</sub>和`有效地资源`<sub>1</sub>范围内，寻找`解决实际问题`<sub>2</sub>的`切实可行`<sub>3</sub>的方案。
> 这就是编程


1. 两个不可避免的限制：进度和资源，这两个现实中的约束把`理想化、形而上的理论研究`和`hands-on、经常要妥协、折中的工程实践`区分开来。  
2. 定义要解决的问题，是`本质问题`还是`伪命题`。避免制定错误的目标、方向。
3. 方案追求`可行`，而非`漂亮`。这需要因地制宜的综合考量，比如因为团队、时间、成本等因素，没有选用某个业界公认的最优方案。这需要开放的思考和灵活的处理。

## 估算进度

> 在众多软件项目中，缺乏的合理的进度安排是造成项目滞后的最主要原因，它比其他所有因素加起来的影响还要大。

> 所有系统编程的进度安排背后的第一个错误的假设是：一切都将运作良好，每一项任务仅花费它所“应该”花费的时间。

> 对于软件任务的进度安排，以下是我使用了很多年的经验法则:  
1/3 计划  
1/6 编码  
1/4 构件测试和早期系统测试  
1/4 系统测试，所有的构件已完成  

估算进度往往难度在于，程序员总是把它和自己的能力挂钩，甚至当做一个竞赛。如果同样一个任务，别人估算 3 天，而你估算 7 天，似乎就会被看低，进度的管理者也可能因此产生疑问。即使你能解释这时间的合理性，别人也容易对此产生"做事效率低"、"能力似乎不如 xxx"的草率论断。

如何算”做完“？3 天如果只是编码完成，没有充分测试，边界检查，这种只估算编码时间的估算是否值得推广？

有经验的程序员常常在安排进度的时候留有时间上的”buffer“，这并非偷懒，相反，这是一个务实的，不盲目乐观的周详之举。


